//中断与原子操作
//我们在前两篇教程中讨论了互斥锁、读写锁以及基于它们的条件变量。互斥锁是一个同步工具，它可以保证每一时刻进入临界区的协程只有一
//个；读写锁对共享资源的写操作和读操作区别看待，并消除了读操作之间的互斥；条件变量主要用于协调想要访问共享资源的那些线程，当共享
//资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程，它既可以基于互斥锁，也可以基于读写锁（当然了，读写锁也是互斥锁，是对后
//者的一种扩展）。通过对互斥锁的合理使用，我们可以使一个 Go 协程在执行临界区中的代码时，不被其他的协程打扰，实现串行执行，不过，虽
//然不会被打扰，但是它仍然可能会被中断（interruption）。
//
//所谓中断其实是 CPU 和操作系统级别的术语，并发执行的协程并不是真的并行执行，而是通过 CPU 的调度不断从运行状态切换到非运行状态，
//或者从非运行状态切换到运行状态，在用户看来，好像是「同时」在执行。我们把代码从运行状态切换到非运行状态称之为中断。中断的时机很
//多，比如任何两条语句执行的间隙，甚至在某条语句执行的过程中都是可以的，即使这些语句在临界区内也是如此。所以我们说互斥锁只能保证临
//界区代码的串行执行，不能保证这些代码执行的原子性，因为原子操作不能被中断。
//
//原子操作通常是 CPU 和操作系统提供支持的，由于执行过程中不会中断，所以可以完全消除竞态条件，从而绝对保证并发安全性，此外，由于
//不会中断，所以原子操作本身要求也很高，既要简单，又要快速。Go 语言的原子操作也是基于 CPU 和操作系统的，由于简单和快速的要求，只
//针对少数数据类型的值提供了原子操作函数，这些函数都位于标准库代码包 sync/atomic 中。这些原子操作包括加法（Add）、比较并交换
//（Compare And Swap，简称 CAS）、加载（Load）、存储（Store）和交换（Swap）。
//
//下面我们简单介绍下这些原子操作。
//
//Go 语言中的原子操作
//加减法
//我们可以通过 atomic 包提供的下列函数实现加减法的原子操作，第一个参数是操作数对应的指针，第二个参数是加/减值
//虽然这些函数都是以 Add 前缀开头，但是对于减法可以通过传递负数实现，不过对于后三个函数，由于操作数类型是无符号的，所以无法显式
//传递负数来实现减法。比如我们测试下 AddInt32 函数：
//var i int32 = 1
//atomic.AddInt32(&i, 1)
//fmt.Println("i = i + 1 =", i)
//atomic.AddInt32(&i, -1)
//fmt.Println("i = i - 1 =", i)

//上述代码打印结果如下：

//i = i + 1 = 2
//i = i - 1 = 1


//https://laravelacademy.org/post/19993