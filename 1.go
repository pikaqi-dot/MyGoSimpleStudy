//在这段代码中包含了两个协程，一个是显式的，通过 go 关键字声明的这条语句，表示启用一个新的协程来处理加法运算，
//另一个是隐式的，即 main 函数本身也是运行在一个主协程中，该协程和调用 add 函数的子协程是并发运行的两个协程，
//就好比从 go 关键字开始，从主协程中叉出一条新路。和之前不使用协程的方式相比，由此也引入了不确定性：我们不知道子
//协程什么时候执行完毕，运行到了什么状态。在主协程中启动子协程后，程序就退出运行了，这就意味着包含这两个协程的处理
//进程退出了，所以，我们运行这段代码，不会看到子协程里运行的打印结果，因为还没来得及执行它们，进程就已经退出了。
//另外，我们也不要试图从 add 函数返回处理结果，因为在主协程中，根本获取不到子协程的返回值，从子协程开始执行起就
//已经和主协程没有任何关系了，返回值会被丢弃。

package main

import "fmt"

func add(a, b int) {
	var c = a + b
	fmt.Printf("%d + %d = %d", a, b, c)
}


func main() {
	go add(1, 2)
}