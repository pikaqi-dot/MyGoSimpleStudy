//---
//## 生产者消费者问题
//- 所谓的生产者消费者模型就是
//+ 某个模块(函数)负责生产数据, 这些数据由另一个模块来负责处理
//+ 一般生产者消费者模型包含三个部分"生产者"、"缓冲区"、"消费者"
//![](https://img-blog.csdnimg.cn/img_convert/c6b9dc46029e893cc11f3a85b7f223f0.png)
//- 为什么生产者消费者模型要含三个部分?  直接生产和消费不行么?
//- 一个案例说明一切
//+ 生产者好比现实生活中的某个人
//+ 缓冲区好比现实生活中的邮箱
//+ 消费者好比现实生活中的邮递员
//- 如果只有生产者和消费者, 那么相当于只有写信的人和邮递员, 那么如果将来过去的邮递员离职了, 你想邮寄信件必须想办法结识新的邮递员(消费者发
//生变化, 会直接影响生产者, 耦合性太强)
//- 如果在生产者和消费者之间添加一个缓冲区, 那么就好比有了邮箱, 以后邮寄信件不是找邮递员, 只需把信件投递到邮箱中即可, 写信的人不需要关心邮
//递员是谁(解耦)
//- 如果只有生产者和消费者, 那么每个人邮寄信件都需要直接找邮递员(1对1关系), 如果有10个人要邮寄信件, 那么邮递员只能依次找到每个人, 然后才能
//取件(效率低下)
//- 如果在生产者和消费者之间添加一个缓冲区, 那么所有的人只需要将信件投递到邮箱即可, 邮递员不用关心有多少人要邮寄信件, 也不用依次取件, 只需要
//找到邮箱从邮箱中统一取件即可(效率提高)
//- 如果只有生产者和消费者, 那么如果邮寄信件太多邮递员无法一次拿走, 这个时候非常难办
//- 如果在生产者和消费者之间添加一个缓冲区, 那么如果信件太多可以先拿走一部分, 剩下的继续放到邮箱中下次再拿
//---
//## 生产者和消费者资源竞争问题
//- 例如生产比较慢, 而消费比较快, 就会导致消费者消费到错误数据
//```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

// 创建一把互斥锁
var lock = sync.Mutex{}

// 定义缓冲区
var sce []int = make([]int, 10)

// 定义生产者
func producer() {
	// 加锁, 注意是lock就是我们的锁, 全局公用一把锁
	lock.Lock()
	rand.Seed(time.Now().UnixNano())
	for i := 0; i < 10; i++ {
		num := rand.Intn(100)
		sce[i] = num
		fmt.Println("生产者生产了: ", num)
		time.Sleep(time.Millisecond * 500)
	}
	// 解锁
	lock.Unlock()
}

// 定义消费者
func consumer() {
	// 加锁, 注意和生产者中用的是同一把锁
	// 如果生产者中已加过了, 则阻塞直到解锁后再重新加锁
	lock.Lock()
	for i := 0; i < 10; i++ {
		num := sce[i]
		fmt.Println("---消费者消费了", num)
	}
	lock.Unlock()
}

func main() {
	go producer()
	go consumer()
	for {

	}
}
